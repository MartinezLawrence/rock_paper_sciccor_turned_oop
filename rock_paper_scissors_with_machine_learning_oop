# Rock Paper Scissors Ultimate Game with Machine Learning

import random
from collections import defaultdict

class RPSGame:
    def __init__(self):
        self.stats = defaultdict(lambda: {'wins': 0, 'losses': 0, 'ties': 0})
        self.transition_matrix = defaultdict(lambda: defaultdict(int))
        self.hidden_found = False
        
        # Game modes
        self.modes = {
            1: {'name': 'Easy', 'choices': ['Rock', 'Paper', 'Scissors']},
            2: {'name': 'Intermediate', 'choices': ['Rock', 'Paper', 'Scissors']},
            3: {'name': 'Expert', 'choices': ['Rock', 'Paper', 'Scissors']},
            4: {'name': 'Super Hard', 'choices': ['Rock', 'Paper', 'Scissors']},
            73: {'name': 'Big Bang', 'choices': ['Rock', 'Paper', 'Scissors', 'Lizard', 'Spock']}
        }
        
        # Win conditions for Big Bang Theory rules
        self.win_conditions = {
            73: {0: [2, 3], 1: [0, 4], 2: [1, 3], 3: [4, 1], 4: [2, 0]},  # Big Bang
            'default': {0: [2], 1: [0], 2: [1]}  # Standard RPS
        }

    def get_valid_input(self, prompt, valid_range, exit_code=None):
        """Get valid integer input from user"""
        while True:
            try:
                choice = int(input(prompt))
                if choice in valid_range or choice == exit_code:
                    return choice
                print(f"Enter a number from {min(valid_range)} to {max(valid_range)}")
            except ValueError:
                print("Please enter a valid number")

    def check_win(self, user_choice, machine_choice, mode):
        """Determine win/loss/tie and update stats"""
        if mode == 73:
            win_against = self.win_conditions[73][user_choice]
        else:
            win_against = self.win_conditions['default'][user_choice]
            
        if machine_choice in win_against:
            result = 'Win!'
            self.stats[mode]['wins'] += 1
        elif user_choice == machine_choice:
            result = 'Tied!'
            self.stats[mode]['ties'] += 1
        else:
            result = 'Lose!'
            self.stats[mode]['losses'] += 1
            
        return result


    def get_machine_choice(self, mode, user_choice=None, prev_choice=None, result=None, **kwargs):
        """Get machine choice based on mode strategy"""
        max_choice = len(self.modes[mode]['choices']) - 1
        
        if mode == 1:  # Easy - Random
            return random.randint(0, max_choice)
            
        elif mode == 2:  # Intermediate - Pattern recognition
            streak = kwargs.get('streak', 0)
            wins = kwargs.get('wins', 0)
            
            if streak > 3:
                return (prev_choice - 2) % 3
            elif wins > 3:
                return prev_choice
            else:
                return random.randint(0, max_choice)
                
        elif mode == 3 or mode == 73:  # Expert/Big Bang - Machine learning
            if prev_choice is not None:
                self.update_transition_matrix(prev_choice, user_choice, result, mode)
                return self.predict_choice(prev_choice, mode)
            return random.randint(0, max_choice)
            
        elif mode == 4:  # Super Hard - Always wins
            return (user_choice - 2) % 3

    def update_transition_matrix(self, prev_choice, current_choice, result, mode):
        """Update transition matrix for machine learning"""
        key = f"{prev_choice}-{current_choice}-{result}"
        self.transition_matrix[mode][key] += 1

    def predict_choice(self, prev_choice, mode):
        """Predict user's next choice based on transition matrix"""
        max_choice = len(self.modes[mode]['choices']) - 1
        
        # Simple prediction based on most common transitions
        transitions = [(k, v) for k, v in self.transition_matrix[mode].items() 
                      if k.startswith(str(prev_choice))]
        
        if not transitions:
            return random.randint(0, max_choice)
            
        # Get most likely next choice and counter it
        most_likely = max(transitions, key=lambda x: x[1])[0].split('-')[1]
        predicted_choice = int(most_likely)
        
        if mode == 73:
            # Counter strategy for Big Bang mode
            counter_choices = []
            for choice, wins_against in self.win_conditions[73].items():
                if predicted_choice in wins_against:
                    counter_choices.append(choice)
            return random.choice(counter_choices) if counter_choices else random.randint(0, max_choice)
        else:
            return (predicted_choice + 1) % 3

    def play_mode(self, mode):
        """Play a specific game mode"""
        choices = self.modes[mode]['choices']
        max_choice = len(choices) - 1
        exit_code = 5 if mode != 73 else 7
        
        # Game state for intermediate mode
        prev_choice = None
        streak = 0
        wins = 0
        
        print(f"\n=== {self.modes[mode]['name']} Mode ===")
        
        while True:
            # Get user choice
            prompt = f"Choose: {', '.join(f'{i}: {c}' for i, c in enumerate(choices))}, {exit_code}: exit\n"
            user_choice = self.get_valid_input(prompt, range(max_choice + 1), exit_code)
            
            if user_choice == exit_code:
                if mode == 73:
                    self.hidden_found = True
                    print("\033[1;36m\nThere's just no pleasing you, is there?\033[0m")
                break
                
            # Super Hard mode shows fake prediction
            if mode == 4:
                print(f"I am going to play {choices[random.randint(0, max_choice)]}")
                
            # Get machine choice
            machine_choice = self.get_machine_choice(
                mode, user_choice, prev_choice, 
                getattr(self, '_last_result', None),
                streak=streak, wins=wins
            )
            
            # Check result
            result = self.check_win(user_choice, machine_choice, mode)
            self._last_result = result
            
            print(f"You chose {choices[user_choice]}")
            print(f"Machine chose {choices[machine_choice]}")
            print(f"You {result}\n")
            
            # Update intermediate mode stats
            if mode == 2:
                if user_choice == prev_choice:
                    streak += 1
                else:
                    streak = max(0, streak - 1)
                if result == 'Win!':
                    wins += 1
                else:
                    wins = max(0, wins - 2)
                    
            prev_choice = user_choice

    def display_stats(self, mode=None):
        """Display statistics"""
        if mode:
            stats = self.stats[mode]
            total = sum(stats.values())
            if total > 0:
                win_rate = stats['wins'] / total * 100
                print(f"\n{self.modes[mode]['name']} Stats:")
                print(f"Wins: {stats['wins']}, Losses: {stats['losses']}, Ties: {stats['ties']}")
                print(f"Win Rate: {win_rate:.1f}%")
        else:
            print("\n=== Final Statistics ===")
            for mode_num, mode_info in self.modes.items():
                if mode_num in self.stats or (mode_num == 73 and self.hidden_found):
                    stats = self.stats[mode_num]
                    total = sum(stats.values())
                    win_rate = (stats['wins'] / total * 100) if total > 0 else 0
                    print(f"{mode_info['name']}: {win_rate:.1f}% win rate")
            
            if not self.hidden_found:
                print("YOU NEVER FOUND THE HIDDEN MODE! (Hint: Bazinga!)")

    def run(self):
        """Main game loop"""
        print(\033[1;36m")
        print("Welcome to Rock Paper Scissors Ultimate!")
        print("Modes: 1-Easy, 2-Intermediate, 3-Expert, 4-Super Hard")
        print("Hidden mode hint: Bazinga!!!")
        print("\033[0m")
        
        while True
            # Choose mode
            mode = self.get_valid_input(
                "Choose mode (1-4) or 73 for hidden mode: ", 
                [1, 2, 3, 4, 73]
            )
            
            # Play selected mode
            self.play_mode(mode)
            self.display_stats(mode)
            
            # Play again?
            while True
                play_again = input("Play again? (yes/no): ").lower()
                if play_again in ['yes', 'y']:
                    break
                elif play_again in ['no', 'n']:
                    self.display_stats()
                    return
                else:
                    print("Please enter yes or no")

if __name__ == "__main__":
    game = RPSGame()
    game.run()
# Rock Paper Scissors Ultimate Game with Machine Learning

import random
from collections import defaultdict

class RPSGame:
    def __init__(self):
        self.stats = defaultdict(lambda: {'wins': 0, 'losses': 0, 'ties': 0})
        self.transition_matrix = defaultdict(lambda: defaultdict(int))
        self.hidden_found = False
        
        # Game modes
        self.modes = {
            1: {'name': 'Easy', 'choices': ['Rock', 'Paper', 'Scissors']},
            2: {'name': 'Intermediate', 'choices': ['Rock', 'Paper', 'Scissors']},
            3: {'name': 'Expert', 'choices': ['Rock', 'Paper', 'Scissors']},
            4: {'name': 'Super Hard', 'choices': ['Rock', 'Paper', 'Scissors']},
            73: {'name': 'Big Bang', 'choices': ['Rock', 'Paper', 'Scissors', 'Lizard', 'Spock']}
        }
        
        # Win conditions for Big Bang Theory rules
        self.win_conditions = {
            73: {0: [2, 3], 1: [0, 4], 2: [1, 3], 3: [4, 1], 4: [2, 0]},  # Big Bang
            'default': {0: [2], 1: [0], 2: [1]}  # Standard RPS
        }

    def get_valid_input(self, prompt, valid_range, exit_code=None):
        """Get valid integer input from user"""
        while True:
            try:
                choice = int(input(prompt))
                if choice in valid_range or choice == exit_code:
                    return choice
                print(f"Enter a number from {min(valid_range)} to {max(valid_range)}")
            except ValueError:
                print("Please enter a valid number")

    def check_win(self, user_choice, machine_choice, mode):
        """Determine win/loss/tie and update stats"""
        if mode == 73:
            win_against = self.win_conditions[73][user_choice]
        else:
            win_against = self.win_conditions['default'][user_choice]
            
        if machine_choice in win_against:
            result = 'Win!'
            self.stats[mode]['wins'] += 1
        elif user_choice == machine_choice:
            result = 'Tied!'
            self.stats[mode]['ties'] += 1
        else:
            result = 'Lose!'
            self.stats[mode]['losses'] += 1
            
        return result

    def get_machine_choice(self, mode, user_choice=None, prev_choice=None, result=None, **kwargs):
        """Get machine choice based on mode strategy"""
        max_choice = len(self.modes[mode]['choices']) - 1
        
        if mode == 1:  # Easy - Random
            return random.randint(0, max_choice)
            
        elif mode == 2:  # Intermediate - Pattern recognition
            streak = kwargs.get('streak', 0)
            wins = kwargs.get('wins', 0)
            
            if streak > 3:
                return (prev_choice - 2) % 3
            elif wins > 3:
                return prev_choice
            else:
                return random.randint(0, max_choice)
                
        elif mode == 3 or mode == 73:  # Expert/Big Bang - Machine learning
            if prev_choice is not None:
                self.update_transition_matrix(prev_choice, user_choice, result, mode)
                return self.predict_choice(prev_choice, mode)
            return random.randint(0, max_choice)
            
        elif mode == 4:  # Super Hard - Always wins
            return (user_choice - 2) % 3


# Method: update_transition_matrix(prev_choice, current_choice, result, mode)
# Update transition count for (prev_choice, current_choice, result) in matrix

# Method: predict_choice(prev_choice, mode)
# Find most common transitions from prev_choice in matrix
# If none, return random choice
# Else, predict user's next likely move and counter it

# Method: play_mode(mode)
# Set up choices and exit code for mode
# Initialize prev_choice, streak, wins
# Print mode info
# Loop:
    # Get user_choice (with exit option)
    # If exit: handle hidden mode if needed, break loop
    # If Super Hard: print fake machine prediction
    # Get machine_choice (using strategy)
    # Check result, print choices and outcome
    # Update streak and wins for Intermediate mode
    # Set prev_choice to user_choice

# Method: display_stats(mode=None)
# If mode given: print stats and win rate for that mode
# Else: print stats for all modes and hidden mode hint if not found

# Method: run()
# Print welcome and mode info
# Loop:
# Get mode from user
# Play selected mode
# Show stats for mode
# Ask if play again; if no, show all stats and exit

